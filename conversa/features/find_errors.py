import datetime

from pydantic import BaseModel

from conversa.features.llm_api import call_llm_structured
from conversa.util.io import DEFAULT_MISTAKES_FILE, append_to_jsonl_file


class ErrorDetail(BaseModel):
    incorrect_part: str
    error_description: str
    corrected_part: str


class Errors(BaseModel):
    errors: list[ErrorDetail]


SYS_PROMPT_ERRORS = """You are a language teacher.
Your task is to check the user's input for any errors in the language the user used.

You should return a structured response that includes the following information for each error found:
1. The incorrect part: it could be a word, phrase, or sentence.
2. A description of the error.
3. The corrected part.

Ignore punctuation mistakes and the letter capitalization as the input is generated by a speech-to-text system.
Ignore the word "start" in the beginning of the conversation and the word "stop" at the end (they are just to start and stop the recording).
"""


def check_for_errors(query: str) -> str:
    """Analyze input text for language errors and return a human-readable report.

    This function calls an LLM-based structured parser to identify language
    errors in the supplied `query`, then formats the returned structured
    information into a readable multi-line string suitable for TTS or printing.

    Args:
        query: User-provided text to analyze.

    Returns:
        A formatted string describing each detected error. If no errors are found,
        returns an empty string.
    """
    errs = call_llm_structured(
        query=query,
        sys_prompt=SYS_PROMPT_ERRORS,
        answer_format=Errors,
    )

    errs_answers: list[str] = []

    if len(errs.errors) > 0:
        print(f'Saving {len(errs.errors)} mistakes to "{DEFAULT_MISTAKES_FILE}"')

    for err in errs.errors:
        errs_answers.append(
            f"You said: '{err.incorrect_part}'. "
            f"This is incorrect. {err.error_description}. "
            f"Corrected part: '{err.corrected_part}'\n"
        )

        data = err.model_dump()
        data["timestamp"] = datetime.datetime.now(datetime.timezone.utc).isoformat()
        append_to_jsonl_file(
            data,
            DEFAULT_MISTAKES_FILE,
        )

    return "\n".join(errs_answers)
